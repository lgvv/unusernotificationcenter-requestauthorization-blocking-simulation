# Investigating Rare Bugs in UNUserNotificationCenter‚Äôs RequestAuthorization on iOS


This repository demonstrates a rare issue observed when using UNUserNotificationCenter.current().requestAuthorization on iOS.<br>
 In certain situations, the completion handler of the authorization request may not be invoked, resulting in a deadlock-like state where execution remains suspended indefinitely.<br>
  This project includes a BlockingSimulationView and related code to reproduce and analyze these behaviors, particularly in relation to thread execution and MainActor isolation.


<br><br>
## Experimental Environment


Xcode: Version 26.0.1 (17A400)<br>
Swift Language Version: Swift 6<br>
Default Actor Isolation: MainActor<br>
Swift Concurrency Checking: Complete


<br><br>
## BlockingSimulation Console Log


This document presents a structured compilation of the logs generated by the `BlockingSimulationView`.<br>
Each tc entry is directly mapped on a one-to-one basis to the corresponding tc identifiers defined within the BlockingSimulationView source file.


```
<details>
<summary>{tc}</summary>
{console log}
</details>
```


<br>


#### Console Log - ServiceOnCompletion

<details>
<summary>TC-ServiceOnCompletion-Main-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
üçç DispatchWorkItem performed by: <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
2Ô∏è‚É£ [SystemAPI] Executed on: <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
3Ô∏è‚É£ [SystemAPI] semaphore.signal() called <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
5Ô∏è‚É£ [run(on:)] Semaphore released, continuing execution <_NSMainThread: 0x600001708040>{number = 1, name = main}
</details>


<details>
<summary>TC-ServiceOnCompletion-Global-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
üçç DispatchWorkItem performed by: <NSThread: 0x6000017274c0>{number = 8, name = (null)}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
2Ô∏è‚É£ [SystemAPI] Executed on: <NSThread: 0x6000017274c0>{number = 8, name = (null)}<br>
3Ô∏è‚É£ [SystemAPI] semaphore.signal() called <NSThread: 0x6000017274c0>{number = 8, name = (null)}<br>
5Ô∏è‚É£ [run(on:)] Semaphore released, continuing execution <_NSMainThread: 0x600001708040>{number = 1, name = main}
</details>


<details>
<summary>TC-ServiceOnCompletion-Current-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001708000>{number = 1, name = main}<br>
üçç DispatchWorkItem performed by: <_NSMainThread: 0x600001708000>{number = 1, name = main}<br>
2Ô∏è‚É£ [SystemAPI] Executed on: <_NSMainThread: 0x600001708000>{number = 1, name = main}<br>
3Ô∏è‚É£ [SystemAPI] semaphore.signal() called <_NSMainThread: 0x600001708000>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001708000>{number = 1, name = main}<br>
5Ô∏è‚É£ [run(on:)] Semaphore released, continuing execution <_NSMainThread: 0x600001708000>{number = 1, name = main}
</details>


<br>


#### Console Log - ServiceOnMainCompletion


<details>
<summary>TC-ServiceOnMainCompletion-Main-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
üçç Concurrency performed by: <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001708040>{number = 1, name = main}
</details>


<details>
<summary>TC-ServiceOnMainCompletion-Global-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
üçç Concurrency performed by: <NSThread: 0x600001708b80>{number = 8, name = (null)}
</details>


<details>
<summary>TC-ServiceOnMainCompletion-Current-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001700080>{number = 1, name = main}<br>
üçç Concurrency performed by: <_NSMainThread: 0x600001700080>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001700080>{number = 1, name = main}
</details>

                
<br>


#### Console Log - ServiceConcurreny


<details>
<summary>TC-ServiceConcurreny-Main-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001708040>{number = 1, name = main}
</details>


<details>
<summary>TC-ServiceConcurreny-Global-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001708000>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001708000>{number = 1, name = main}
2Ô∏è‚É£ [SystemAPI] Task running on thread: <NSThread: 0x60000170fb80>{number = 10, name = (null)}
</details>


<details>
<summary>TC-ServiceConcurreny-Current-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001704080>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001704080>{number = 1, name = main}
</details>


<br>


#### Console Log - ServiceConcurrenyReturnOnMain


<details>
<summary>TC-ServiceConcurrenyReturnOnMain-Main-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x6000017040c0>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x6000017040c0>{number = 1, name = main}
</details>


<details>
<summary>TC-ServiceConcurrenyReturnOnMain-Global-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001708040>{number = 1, name = main}<br>
2Ô∏è‚É£ [SystemAPI] Task running on thread: <NSThread: 0x60000170c900>{number = 2, name = (null)}
</details>


<details>
<summary>TC-ServiceConcurrenyReturnOnMain-Current-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001704040>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001704040>{number = 1, name = main}
</details>


<br>


#### Console Log - ServiceConcurrentConcurrenyReturnOnMain


<details>
<summary>TC-ServiceConcurrenyReturnOnMain-Main-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001708000>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001708000>{number = 1, name = main}
</details>


<details>
<summary>TC-ServiceConcurrenyReturnOnMain-Global-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x6000017000c0>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x6000017000c0>{number = 1, name = main}<br>
2Ô∏è‚É£ [SystemAPI] Task running on thread: <NSThread: 0x60000172d700>{number = 9, name = (null)}<br>
üçç Concurrency performed by: <NSThread: 0x60000172d700>{number = 9, name = (null)}
</details>


<details>
<summary>TC-ServiceConcurrenyReturnOnMain-Current-001</summary>
1Ô∏è‚É£ [run(on:)] Function started on: <_NSMainThread: 0x600001700080>{number = 1, name = main}<br>
4Ô∏è‚É£ [run(on:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001700080>{number = 1, name = main}
</details>


<br>


#### Analysis of Logs


The console logs were analyzed to compare normal and abnormal execution flows.<br>
In normal cases, all steps proceed sequentially, and execution resumes correctly after the `semaphore.signal()` call, indicating that the system callback has been successfully received.<br>
However, in certain instances, the log output fails to reach the expected subsequent steps.<br>
Although this behavior is theoretically straightforward from a computer science perspective, it appears to be influenced by Apple‚Äôs internal implementation.<br>
Therefore, cases in which the execution flow does not complete are identified as the core manifestation of the issue.


<br><br>
## MockSimulation 

MockSimulation is designed to emulate the internal behavior of Apple‚Äôs system APIs in order to reproduce scenarios where potential bugs may occur.<br>
Particular attention was paid to the statement in documents `https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/requestauthorization(options:completionhandler:)` indicating that the completionHandler could be executed on a background thread.<br>
Accordingly, the simulation was primarily designed to reproduce and investigate thread-related behaviors and potential concurrency issues.


<blockquote>
<strong>Note:</strong> TC-MockSimulation-Global-001 triggers a diagnostic warning indicating a call to a MainActor-isolated instance method <code>perform()</code> from a synchronous, nonisolated context.
</blockquote>


<details>
<summary>TC-MockSimulation-Main-001</summary>
1Ô∏è‚É£ [requestAuthorization(isRunOnMainThread:)] Function started on: <_NSMainThread: 0x600001700040>{number = 1, name = main}<br>
4Ô∏è‚É£ [requestAuthorization(isRunOnMainThread:)] Waiting for signal‚Ä¶ <_NSMainThread: 0x600001700040>{number = 1, name = main}
</details>


<details>
<summary>TC-MockSimulation-Global-001</summary>
1Ô∏è‚É£ [perform()] Function started on: <NSThread: 0x60000170b440>{number = 3, name = (null)}<br>
4Ô∏è‚É£ [perform()] Waiting for signal‚Ä¶ <NSThread: 0x60000170b440>{number = 3, name = (null)}<br>
MockAlertController initialized <_NSMainThread: 0x60000170c000>{number = 1, name = main}<br>
MockAlertController called viewDidLoad <_NSMainThread: 0x60000170c000>{number = 1, name = main}<br>
MockAlertController called viewDidDisappear <_NSMainThread: 0x60000170c000>{number = 1, name = main}<br>
2Ô∏è‚É£ [SystemAPI] Executed on: <_NSMainThread: 0x60000170c000>{number = 1, name = main}<br>
3Ô∏è‚É£ [SystemAPI] semaphore.signal() called <_NSMainThread: 0x60000170c000>{number = 1, name = main}<br>
5Ô∏è‚É£ [perform()] Semaphore released, continuing execution <NSThread: 0x60000170b440>{number = 3, name = (null)}
</details>


<br><br>
## TechnicalSupportSampleView

The following code sample illustrates the section of the project where the issue occurs.<br> 
Although reproducing the problem is not straightforward, it has been observed to occur with a very low frequency.<br>
Nevertheless, recent user reports indicate that this issue has begun to appear in actual usage scenarios.<br>
The actual project includes portions of Objective-C code, which may lead to certain issues not being detected during diagnostics.<br>
In particular, when this issue occurs, using the Concurrency code from the official documentation as-is results in the `await` not actually suspending, causing execution to continue immediately.
